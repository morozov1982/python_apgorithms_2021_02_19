# Важные заметки по 6 уроку

### Временные метки

**00:00** - Ждёмс<br />
**09:30** - "Добрый вечер, коллеги"

## Разбор д/з (10:30)

### *Задача №1* (10:30)

Если в коде используется больше 2-3 нумерованных переменных
типа `p1, p2, p3`, лучше использовать коллекции (`list` и др.).

**13:35** - Вопросы от студентов (не по сути)<br />
**16:00** - *Продолжаем задачу №1*<br />

``` Python3
num = 0

# Лучше:
for i in range(1, num + 1):
    print(f'{i}')

# Чем:
for i in range(num):
    print(f'{i + 1}')
```

**20:10** - Вариант вывода 1<br />
**22:10** - Вариант вывода 2: через очереди (`deque()`)<br />

``` Python3
sort_comp = deque([None])
for comp in all_companies:
    if comp.profit > average:  # Прибыльные компании
        sort_comp.append(comp)  # добавляем справа от None
    elif comp.profit < average:  # убыточные
        sort_comp.appendleft(comp)  # слева

text = 'меньше'
for comp in sort_comp:
    if comp is None:
        text = 'больше'
    else:
        print(f'Компания {comp.name} заработала {text}, чем средняя прибыль - {comp.profit}')
```

**24:30** - *Вопросы по задаче №1*

### *Задача №2* (27:15)

**27:50** - Сложение столбиком<br />
**28:40** - Умножение столбиком

**30:50** - *Продолжаем задачу №2*<br />
**33:15** - Функция суммирования

**36:00** - `if overflow == 1` или `is_overflow = True or False`

**37:00** - *Вопросы по сложению*

**41:00** - *Продолжаем задачу №2*: Функция умножения

**44:15** - *Вопросы по умножению*

## Тема урока №6: *"Работа с динамической памятью"* (46:10)

В Pyton представление памяти в виде **кучи (heap)**.

**47:35** - *Вопрос:* все ли знают структуру данных стек?

**48:20** - **Объяснение кучи** и как она работает в Python<br />
**50:30** - Сборщик мусора

**51:45** - **Для чего этот урок?** - оценка затрат памяти

**53:10** - *Вопрос:* само часто используемая коллекция в Python? - по опыту — строки

**54:20** - Пояснение по переменным: в Python всё — объект. Как устроен объект.

**55:45** - Как устроен список (`list`) (см. python list.pdf):

*56:00* - стр. 1 - `a = [1]` - ячейки: 4, занятые: 1, свободные: 3<br />
*58:30* - стр. 2 - `a.extend([2, 3, 4])` - ячейки: 4, занятые: 4, свободные: 0<br />
*01:00:20* - стр. 3 - `a.insert([1, 5])` - ячейки: 8, занятые: 5, свободные: 3,
смещаются элементы 1-3 включительно, записываем в 1 ячейку<br />
*01:04:20* - стр. 4 - `spam = a.pop()` - ячейки: 8, занятые: 4, свободные: 4,
теперь переменная `spam` указывает на 4 объект<br />
*01:05:30* - стр. 5 - `spam = a.pop()`, ещё раз — ячейки: 6, занятые: 3, свободные: 3<br />
*01:06:10* - стр. 6 - `a.remove(5)` - ячейки: 5, занятые: 2, свободные: 3,
проходимся по всем занятым ячейкам списка, линейная асимптотика O(n).

**01:08:15** - *Вопросы*<br />
**01:08:15** - **Перерыв**

### Работаем в PyCharm в Python Console (01:18:15)

``` Python3
>>> a = 100
>>> b = 123 - 23
>>> id(a)
9788064
>>> id(b)
9788064
```

``` Python3
c = 1000
d = 1234 - 234
id(c)
139906335940336
id(d)
139906333651088
```

**01:22:15** - переменные от -5 до 255 ссылаются на один и тот же объект в памяти — оптимизация

### Работаем в PyCharm в редакторе кода (01:24:30)

``` Python3
# см. lesson_6/task_1.py (3-6, 8 строки)
a = 100
b = 123 - 23
c = 1000
d = 1234 - 234
print(id(a), id(b), id(c), id(d))  # 9788064 9788064 140421504879504 140421504879504
```

В данном случае при переводе в байт-код Python
при первом проходе сразу вычисляет значения и одинаковые не дублирует.

**01:27:05** - *Вопросы*

**01:28:00** - `sys.getrefcount()` - количество ссылок на объект, на который ссылается переменная

``` Python3
# см. lesson_6/task_1.py (1, 10-15 строки)
import sys

e = 'Hello world!'
print(sys.getrefcount(e))  # 4
f = e
print(sys.getrefcount(e))  # 5
g = 'Hello world!'
print(sys.getrefcount(e))  # 6
def f  # не удаляет, а рвёт связи
print(sys.getrefcount(e))  # 5
```

**01:32:00** - *Вопросы*

**01:33:30** - По-поводу счётчика ссылок и ссылок на объекты

``` Python3
# см. lesson_6/task_1.py (1, 17-19 строки)
iprint(sys.getrefcount(True))   # 109
print(sys.getrefcount(False))  # 113
print(sys.getrefcount(None))   # 4088
```

**01:35:00** - `sys.getsizeof()` - Сколько оперативной памяти занимает объект

``` Python3
print(sys.getsizeof(42))  # 28 байт занимает объек, а его адрес - 4 байта
```

**01:36:35** - *Пояснение:* сколько памяти занимают объект и ссылка на него

**01:37:50** - *Вопрос:* слышали, объект целого типа (int) резиновый?

``` Python3
# см. lesson_6/task_1.py (22-24 строки)
i = 42654562435536436263445453474537685638356737543256257543724
print(sys.getsizeof(i)  # При увеличении числа, число байт тоже увеличивается
print(i)  # точность сохраняется
```

**01:39:50** - То же самое с float

``` Python3
# см. lesson_6/task_1.py (25-27 строки)
f = 45736346752.54657435678625634
print(sys.getsizeof(f))  # всегда 24 байта в 64-разрядной системе, 12 - в 32
print(f)  # точность страдает
```

**01:41:20** - *Вопрос:* сколько места занимает строка 'Hello world!' в оперативной памяти?

``` Python3
# см. lesson_6/task_1.py (8 строка)
print(sys.getsizeof('Hello world!'))  # 61 (1 символ - 1 байт [для ASCII] + 48 байт служебной информации)

print(sys.getsizeof('Hello world!ж'))  # 100 ('ж' - 2 байта [UTF8]) из-за 'ж' теперь каждая уква занимает 2 байта
```

**01:46:00** - *Вопросы* - int / 1 - при переводе в float точность теряется,
если использовать int // 1, точность сохраняется

### Спойлер к д/з (01:47:40) - *lesson_6/task_2.py*

``` Python3
# см. lesson_6/task_1.py (1-5, 16 строки)
import sys

def show(obj):
    print(f'{type(obj)=}, {sys.getsizeof(obj)=}, {obj=}')

show(42)  # type(obj)=<class 'int'>, sys.getsizeof(obj)=28, obj=42
```

**01:50:10**<br />
**01:50:30** - `[i for i in range(10)]` - **правильно**, `[_ for _ in range(10)]` - неверно

``` Python3
# см. lesson_6/task_1.py (6-13, 18-19 строки)
import sys

def show(obj):
    print(f'{type(obj)=}, {sys.getsizeof(obj)=}, {obj=}')
    if hasattr(obj, '__iter__'):
        if hasattr(obj, 'items'):
            for key, value in obj.items():
                show(key)
                show(value)
        else:
            for item in obj:
                show(item)

lst = [i for i in range(10)]
show(lst)  # type(obj)=<class 'list'>, sys.getsizeof(obj)=184, obj=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
**01:55:20** - *Вопрос:* почему объекты занимают 276 байт, а список - 184?

184 - служебная информация + 4-байтовые ссылки на объекты

**01:57:10** - следующий момент по поводу списков:<br />
если объектов в списке будет 11 вместо 10, размер тоже будет 184, потому что в резерве есть ещё ячейки

**01:58:00**
``` Python3
# см. lesson_6/task_1.py (21 строку)
show(tuple(lst))  # type(obj)=<class 'tuple'>, sys.getsizeof(obj)=120, obj=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```
120 - `tuple()` занимает меньше, чем `list()`, потому что не резервирует ячейки

**01:59:15** - если объектов в кортеже будет 11 вместо 10,
размер изменится со 120 до 128 байт.<br />
Для одной ячейки памяти в 64-разрядной ОС выделяется 8 байт памяти.

**02:00:30**
``` Python3
# см. lesson_6/task_1.py (25, 26 строки)
show(set(lst))  # type(obj)=<class 'set'>, sys.getsizeof(obj)=728, obj={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
show({f'{i}': i for i in range(10)})  # выводит ошибку ;-)
```

`set()` - массив, который добавляет объекты по их хешу

**02:03:05** - про ошибку со строкой, см. код выше. Превышена максимальная глубина рекурсии.

**02:05:00** - `show('Hello')  # тоже ошибка`<br />
**02:06:20** - поэтому используем `elif`:
``` Python3
# см. lesson_6/task_1.py (11-13 строки)
# теперь функция выглядит так
def show(obj):
    print(f'{type(obj)=}, {sys.getsizeof(obj)=}, {obj=}')
    if hasattr(obj, '__iter__'):
        if hasattr(obj, 'items'):
            for key, value in obj.items():
                show(key)
                show(value)
        elif not isinstance(obj, str):
            for item in obj:
                show(item)

show({f'{i}': i for i in range(10)})  # type(obj)=<class 'dict'>, sys.getsizeof(obj)=360, obj={'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
show('Hello')  # type(obj)=<class 'str'>, sys.getsizeof(obj)=54, obj='Hello'
```

54 байт = 48 байт служебной информации + 5 байт (по байту на символ) + байт (символ переноса строки, который не видно '\n')

**02:07:20** - *Вопросы*

## Как выполнять д/з (02:09:30)

1. Взять интересную задачу, которую имеет смысл оценивать по памяти;
2. Написать 3 варианта кода (1 уже есть), использовать разные структуры данных;
3. Посчитать сумму байт (3 задачи - 3 суммы);
4. Комментарий с суммой байт (указать ОС, разрядность системы, версию Python);
5. Выводы: какой вариант эффективнее, почему.

**02:12:15** - Чтобы понять, какое количество байт расходует объект,
использовать `sys.getsizeof()`.<br />
В хорошем решении `sys.getsizeof()` встречается всего 1 раз.<br />
!!! Не забыть посчитать сумму !!!

**Абстрактный пример программы:**
``` Python3
a = 42
b = 'text'
c = [1, 2, 4]
for i in c:
    print(i)  # считать последний i
>>> сумма  # сумму считает программа, а не мы руками ;-)
```

**02:15:40** - *Вопросы*

Делитесь промежуточными решениями в чате.

**02:19:05** - "Пока"<br />
**+ Лорн Бэлф:** "Terminator Genisys (Music from the Motion Picture)" ;-)